(function() {
  var Command, Compiler, Range, Xecute, deasync, pygmentize,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Command = require('../command');

  Range = require('../range');

  Compiler = require('../compiler');

  pygmentize = require('pygmentize-bundled');

  deasync = require('deasync');

  Xecute = (function(superClass) {
    extend(Xecute, superClass);

    Xecute.prototype.name = '';

    Xecute.prototype.last_error = null;

    Xecute.prototype.args = new Range(1, Infinity);

    function Xecute() {
      var isCoffee;
      Xecute.__super__.constructor.apply(this, arguments);
      isCoffee = this.app.isStandAlone || this.find_file().type() === 'coffee';
      this.compiler = new Compiler({
        scope: this.scope,
        isCoffee: isCoffee
      });
      this.prompt.mode = this.compiler.mode();
      this.code = '';
      this.indent = '';
    }

    Xecute.prototype.execute = function(input, chain) {
      var res;
      if (input[0] === 'mode') {
        return this.switch_mode(chain);
      }
      res = this.execute_code(input.join(' '));
      return (res != null ? typeof res.then === "function" ? res.then(function() {
        return chain.next();
      }) : void 0 : void 0) || chain.next();
    };

    Xecute.prototype.colorizeLastLine = function(prompt, code, lang) {
      var done, results;
      done = false;
      pygmentize({
        lang: lang,
        format: "terminal"
      }, code, (function(_this) {
        return function(_, res) {
          done = true;
          process.stdout.moveCursor(0, -1);
          return console.log(prompt + res.toString().trim());
        };
      })(this));
      results = [];
      while (!done) {
        results.push(deasync.runLoopOnce());
      }
      return results;
    };

    Xecute.prototype.eval_code = function(code, language) {
      var next, res;
      this.prompt.indent = this.indent;
      res = this.compiler.execute(this.code + this.indent + code, language);
      next = (function(_this) {
        return function(res) {
          _this.output.prettySend(res);
          return _this.code = _this.indent = '';
        };
      })(this);
      return (res != null ? typeof res.then === "function" ? res.then(next)["catch"](next) : void 0 : void 0) || next(res);
    };

    Xecute.prototype.execute_code = function(code, language) {
      var err, error, hasTrailingBackslash, prompt, shouldDecreaseIndent, shouldIncreaseIndent;
      if (language == null) {
        language = this.compiler.mode();
      }
      try {
        if (language !== 'coffee') {
          return this.output.prettySend(this.compiler.execute(code, language));
        }
        shouldDecreaseIndent = code.match(/^\s*(\}|\]|else|catch|finally|else\s+if\s+\S.*)$/) != null;
        prompt = this.prompt.cli._prompt;
        if (code && shouldDecreaseIndent) {
          this.indent = this.indent.slice(0, -2);
          prompt = prompt.slice(0, -2);
          code += '  ';
        }
        if (process.env.PRYINPUTCOLOR != null) {
          if (code) {
            this.colorizeLastLine(prompt, code, language);
          }
        } else {
          process.stdout.moveCursor(0, -1);
          console.log(prompt + code);
        }
        shouldIncreaseIndent = code.match(/^\s*(.*class\s|[a-zA-Z\$_](\w|\$|:|\.)*\s*(?=\:(\s*\(.*\))?\s*((=|-)&gt;\s*$))|[a-zA-Z\$_](\w|\$|\.)*\s*(:|=)\s*((if|while)(?!.*?then)|for|$)|(if|while|unless)\b(?!.*?then)|(for|switch|when|loop)\b|(else|try|finally|catch\s+\S.*|else\s+if\s+\S.*)\s*$|.*[-=]&gt;$|.*[\{\[]$)|\-\>\s*$/) != null;
        hasTrailingBackslash = code.trim().slice(-1) === '\\';
        if (shouldIncreaseIndent || hasTrailingBackslash) {
          this.code += this.indent + (hasTrailingBackslash ? code.slice(0, -1) : code) + "\n";
          this.indent += '  ';
        } else {
          if (this.indent) {
            if (code) {
              this.code += this.indent + code + "\n";
            } else {
              this.prompt.count--;
              this.indent = this.indent.slice(0, -2);
              if (this.indent) {
                process.stdout.moveCursor(0, -1);
              } else {
                return this.eval_code(code);
              }
            }
          } else {
            return this.eval_code(code);
          }
        }
        return this.prompt.indent = this.indent;
      } catch (error) {
        err = error;
        this.prompt.indent = this.code = this.indent = '';
        this.last_error = err;
        return this.output.send(err);
      }
    };

    Xecute.prototype.switch_mode = function(chain) {
      this.compiler.toggle_mode();
      this.prompt.mode = this.compiler.mode();
      this.output.send("Switched mode to '" + (this.compiler.mode()) + "'.");
      return chain.next();
    };

    Xecute.prototype.match = function(input, chain) {
      return [input, input];
    };

    return Xecute;

  })(Command);

  module.exports = Xecute;

}).call(this);
