(function() {
  var AutoComplete, Compiler,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Compiler = require('./compiler');

  AutoComplete = (function() {
    var ACCESSOR, KEYWORDS, SIMPLEVAR, THISPROP;

    ACCESSOR = /\s*([\@\w\.]+)(?:\.(\w*))$/;

    THISPROP = /\s*(\@)(\w*)/;

    SIMPLEVAR = /\s*(\w*)$/i;

    KEYWORDS = ['undefined', 'then', 'unless', 'until', 'loop', 'of', 'by', 'when', 'require', 'true', 'false', 'null', 'this', 'new', 'delete', 'typeof', 'in', 'instanceof', 'return', 'throw', 'break', 'continue', 'if', 'else', 'switch', 'for', 'while', 'do', 'try', 'catch', 'finally', 'class', 'extends', 'super', 'whereami', 'kill!', 'exit', 'wtf', 'play', 'version', 'help'].concat(Object.getOwnPropertyNames(global));

    function AutoComplete(scope, file) {
      this.scope = scope;
      this.file = file;
      this.autocomplete = bind(this.autocomplete, this);
      this.localVars = this.file.getLocalVariables();
      this.compiler = new Compiler({
        scope: this.scope,
        isCoffee: true
      });
    }

    AutoComplete.prototype.autocomplete = function(text) {
      var e, error1;
      try {
        return this.completeAttribute(text) || this.completeVariable(text) || [[], text];
      } catch (error1) {
        e = error1;
        return [[], []];
      }
    };

    AutoComplete.prototype.completeAttribute = function(text) {
      var all, completions, error, error1, match, obj, prefix, val;
      if (match = text.match(ACCESSOR) || text.match(THISPROP)) {
        all = match[0], obj = match[1], prefix = match[2];
        try {
          val = this.compiler.execute(obj);
        } catch (error1) {
          error = error1;
          return [[], text];
        }
        completions = this.getCompletions(prefix, this.getPropertyNames(val));
        return [completions, prefix || ''];
      }
    };

    AutoComplete.prototype.completeVariable = function(text) {
      var free, globalVars, key, ref;
      if (free = (ref = text.match(SIMPLEVAR)) != null ? ref[1] : void 0) {
        globalVars = (function() {
          var results;
          results = [];
          for (key in global) {
            if (!hasProp.call(global, key)) continue;
            if (KEYWORDS.indexOf(key) === -1) {
              results.push(key);
            }
          }
          return results;
        })();
        return [this.getCompletions(free, this.localVars.concat(KEYWORDS, globalVars)), free];
      }
    };

    AutoComplete.prototype.getCompletions = function(prefix, candidates) {
      var el, i, len, results;
      if (prefix) {
        results = [];
        for (i = 0, len = candidates.length; i < len; i++) {
          el = candidates[i];
          if (el.indexOf(prefix) === 0) {
            results.push(el);
          }
        }
        return results;
      } else {
        return candidates;
      }
    };

    AutoComplete.prototype.getPropertyNames = function(obj) {
      var _, i, key, keys, len, methods, name, props, tmpObj;
      if (typeof obj === 'string') {
        props = Object.getOwnPropertyNames(String.prototype);
      } else if (obj instanceof Array) {
        props = Object.getOwnPropertyNames(Array.prototype);
      } else if (obj === Object || obj === Reflect) {
        props = Object.getOwnPropertyNames(obj);
      } else {
        methods = new Set();
        tmpObj = obj;
        while ((tmpObj = Reflect.getPrototypeOf(tmpObj))) {
          keys = Reflect.ownKeys(tmpObj);
          if (indexOf.call(keys, '__proto__') >= 0) {
            break;
          }
          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            if (key !== 'constructor' && typeof key !== 'symbol') {
              methods.add(key);
            }
          }
        }
        props = Array.from(methods);
      }
      return props.concat((function() {
        var results;
        results = [];
        for (name in obj) {
          _ = obj[name];
          results.push(name);
        }
        return results;
      })());
    };

    return AutoComplete;

  })();

  module.exports = AutoComplete;

}).call(this);
